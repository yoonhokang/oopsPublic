# 누구나 이해하는 인증(Authentication)과 권한(Authorization) 이야기

**Date:** 2026-02-19 18:10
**Topic:** 현재 상황에 대한 비유적 설명 (403 vs 404)

## 1. 비유: "회사 건물 출입"

현재 우리가 겪고 있는 상황을 **"회사 건물 출입"**에 비유해 보겠습니다.

### 등장 요소:
1.  **사용자 (User):** 웹사이트 방문자 (당신).
2.  **신분증 (Token):** 로그인 하면 발급받는 ID 카드. ("나 여기 직원이에요" 증명)
3.  **건물 주소 (Endpoint):** 우리가 접속하려는 데이터베이스 주소. (서울 / default)
4.  **경비원 (Security Rules):** 문 앞에서 신분증을 검사하는 사람. ("직원이면 통과!")
5.  **자동 개찰구 (API Key):** 신분증을 찍어야 열리는 기계. (시스템 레벨의 출입 통제)

### 현재 상황 시나리오:
1.  **사용자**가 로그인해서 **신분증(Token)**을 완벽하게 발급받았습니다. (확인 완료)
2.  **건물 주소(Seoul)**도 정확하게 찾아갔습니다. (404 해결)
3.  **경비원(Rules)**에게 "저 직원입니다"라고 했더니, "어서 오세요(Pass)"라고 했습니다. (룰 완화 완료)
4.  그런데, **자동 개찰구(API Key)**에 카드를 찍었더니 **"삐- (차단됨)"** 소리가 납니다.
    *   **이유:** 이 개찰구는 "이메일 업무(Auth)"만 처리하도록 세팅되어 있고, "창고 문(Firestore)"을 여는 기능은 꺼져있기 때문입니다.

## 2. 질문에 대한 답변

**Q1. 현재 데이터베이스에 접근이 거부되는 건가요? 아니면 데이터베이스가 없는 건가요?**
**A: "접근이 거부되는 것(Access Denied)"입니다. 데이터베이스는 확실히 존재합니다.**

*   **진단 근거:**
    *   만약 데이터베이스가 없었다면 **404 Not Found (주소 없음)** 에러가 떴을 것입니다. (어제 우리가 겪었던 문제)
    *   지금 뜨는 **403 Forbidden** 에러는 **"거기에 있는 건 알겠는데, 넌 못 들어와"**라는 뜻입니다.
    *   즉, 우리는 올바른 문 앞까지 갔고, 문도 두드렸지만, 잠겨 있어서 못 들어가는 상태입니다.

**Q2. 왜 읽기/쓰기 모두 거부되나요?**
개찰구(API Key) 자체가 막혀있기 때문입니다.
*   읽기(Read)도 문을 열고 들어가야 하고,
*   쓰기(Write)도 문을 열고 들어가야 합니다.
*   입구(Gateway) 컷을 당하고 있기 때문에 어떤 작업도 불가능한 것입니다.

**"이 개찰구는 '창고(Firestore)' 출입도 허용한다"**라고 체크박스 하나만 켜주면, 삐 소리 없이 문이 열릴 것입니다. (GCP Console 설정)

## 4. 추가 질문 답변 (Q&A)

**Q3. API란 무엇이고, API Key는 함수 입력값 같은 건가요?**
**A: 네, 정확합니다!**
*   **API (Application Programming Interface):** 자판기 같은 "기능 제공 장치"입니다. 버튼(함수)을 누르면 물건(데이터)이 나옵니다.
*   **API Key:** 자판기를 작동시키기 위한 **"전용 동전"** 혹은 **"가맹점 카드"**입니다.
    *   구글 서버(자판기)는 아무나 버튼을 누르게 두지 않습니다.
    *   "너 우리랑 계약된 앱(Project) 맞니?"를 확인하기 위해 `key=...` 값을 요구합니다.
    *   이 키가 일치하지 않거나, 권한이 없는 키라면 자판기는 작동을 거부합니다.

**Q4. API Key는 사용자 토큰과 관계가 없나요?**
**A: 네, 완전히 별개입니다.**
*   **API Key = "이 앱의 신분증"**
    *   "나 `oopsPublic`이라는 앱이야. 문 열어줘."
    *   사용자가 누구든 상관없이 **앱 자체의 권한**을 증명합니다.
*   **User Token = "사용자의 신분증"**
    *   "나 `kangyoonho@gmail.com`이라는 사람이야. 내 데이터 내놔."
    *   앱 안에서 **누가** 요청했는지를 증명합니다.

**결론:**
지금 상황은 **사용자(Token)**는 멀쩡한데, **앱(API Key)**이 "Firestore"라는 자판기를 쓸 권한이 없어서 막히는 것입니다.
앱에게 "너도 Firestore 써도 돼"라고 허락(체크박스)해주면 해결됩니다.

**Q5. 근데 저희는 별도로 인증 키를 획득한 적이 없는데요?**
**A: 프로젝트 생성 시 자동으로 발급되었습니다.**
*   `js/api-config.js` 파일을 열어보시면 `apiKey: "AIza..."`로 시작하는 긴 문자열이 있을 것입니다.
*   이것이 바로 Firebase 프로젝트를 처음 만들 때 **구글이 자동으로 생성해준** 키입니다.
*   우리는 의식하지 못했지만, 앱은 시작할 때부터 이 키를 사용해서 "저 `oopsPublic` 앱입니다"라고 구글에 신고하고 있었던 것입니다.

**Q6. 정확히 무엇이 막히는 건가요?**
**A: "이 키를 들고 온 요청 전용"으로 Firestore 문이 잠긴 것입니다.**
*   API Key는 일종의 **"출입증"**입니다.
*   구글 클라우드 설정(GCP)에서 이 출입증에 대해 **"이걸로는 로그인(Auth)만 되고, DB(Firestore)는 들어가지 마"**라고 제약을 걸어둔 상태인 것입니다.
*   그래서 우리가 해야 할 일은 **"이 출입증으로 DB도 들어가게 해줘"**라고 설정을 풀어주는 것뿐입니다.

## 5. 최종 이해도 점검 (User's Summary)

**Q7. 위 키는 Firebase가 구글에서 자동으로 받은 건가요?**
**A: 정답입니다.** (Firebase 프로젝트 생성 = Google Cloud 프로젝트 생성 + 키 자동 발급)

**Q8. 구글에서 제공하는 API는 위와 같은 키가 반드시 필요한가요?**
**A: 정답입니다.**
구글의 모든 API(지도, 번역, 유튜브, 파이어스토어 등)는 "누가(어떤 앱이) 썼는지" 기록하고 과금하기 위해 **반드시 API Key를 요구합니다.**

**Q9. 토큰은 Firebase가 인증하고, 그 인증된 요청을 Firebase가 키와 함께 구글 API에 요청하는 건가요?**
**A: 완벽한 이해입니다!**
*   **1단계 (Auth):** 사용자가 로그인 -> Firebase가 신분증(Token) 발급.
*   **2단계 (Request):** 앱이 신분증(Token)과 출입증(API Key)을 둘 다 챙겨서 -> 구글 서버(Firestore)에 요청.
*   **3단계 (Verify):** 구글 서버가 둘 다 확인함.
    *   토큰 확인: "아, `kangyoonho`님이시군요. (O)"
    *   키 확인: "어? 이 키는 `oopsPublic` 앱 키인데, Firestore 사용 권한이 없네요. (X - **현재 상황**)"

**→ 키 권한만 풀어주면 3단계가 통과됩니다.**

**Q10. 왜 우리 앱이 키를 가져야 하죠? Firebase한테 시키면 안 되나요?**
**A: 우리 앱이 곧 "Firebase(클라이언트)"이기 때문입니다.**
*   **전통적인 방식 (Server):** `내 앱` -> `내 서버` -> `구글 서버`
    *   이 경우 "내 서버"만 키를 알면 됩니다.
*   **Firebase 방식 (Serverless):** `내 앱(브라우저)` -> `구글 서버`
    *   중간에 거치는 서버가 없습니다. (그래서 빠르고 저렴합니다.)
    *   브라우저가 직접 구글 서버와 통신해야 하므로, **브라우저가 키를 가지고 있어야 합니다.**
    *   "Firebase SDK"라는 친구가 브라우저에 살면서 구글과 통신하는 대리인 역할을 하는데, 이 대리인에게도 출입증(API Key)이 필요한 것입니다.

